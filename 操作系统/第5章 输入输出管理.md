## 一、I/O 管理概述
### 1、I/O 设备
#### （1）设备的分类
##### 1）按信息交换的单位
- **块设备**：
	- 信息交换以数据块为单位，如磁盘、磁带
	- 基本特征：传输速率较高、可寻址，即对它可随意地读/写任意一块
	- 属于有结构设备
- **字符设备**：
	- 信息交换以字符为单位，如交互式终端机、打印机
	- 基本特征：传输速率低、不可寻址，常采用中断 I/O 方式
	- 属于无结构设备

##### 2）按设备的传输速率
- **低速设备**：键盘、鼠标
- **中速设备**：激光打印机
- **高速设备**：磁盘机、光盘机

##### 3）按设备的共享属性
- **独占设备**：
	- 一个时刻只能由一个进程占用
	- 所有字符设备都是独占设备
	- 速度慢，利用率低
	- 如输入机、打印机、磁带机
- **共享设备**：
	- 同一时间段内允许多个进程同时访问的设备
	- 共享设备必须是可寻址和可随机访问的设备
	- 如软硬盘、磁盘、光盘
- **虚拟设备**：
	- 通过 SPOOLing 技术将独占设备改造为共享设备
	- 将一个物理设备变为多个逻辑设备，从而可将设备同时分配给多个进程
	- 实质上还是独占设备

##### 4）按设备的使用特性
- **存储设备**：
	- 存储信息的外部设备
	- 如磁盘、磁带、光盘
- **输入/输出设备**：
	- 输入设备：向计算机输入外部信息，如键盘、鼠标、扫描仪
	- 输出设备：计算机向外输出数据信息，如打印机
	- 交互式设备：集成两种功能，如触控显示器

#### （2）设备控制器（I/O 接口）
##### 1）主要功能
- 接受和识别 CPU 发出的命令
- 向 CPU 报告设备的状态
- 数据交换
- 地址识别
- 数据缓冲
- 差错控制

##### 2）组成
- **设备控制器与 CPU 的接口**：
	- 用于实现 CPU 与控制器之间的通信，有三类信号线
	- 数据线：传送的是读/写数据、控制信息和状态信息
	- 地址线：传送的是要访问 I/O 接口中的寄存器编号
	- 控制线：传送的是读/写等控制信号
- **设备控制器与设备的接口**：
	- 用于实现控制器和设备之间的通信
	- 控制器中有一个或多个设备接口
	- 每个接口都可传输数据、控制和状态三种类型的信号
- **I/O 逻辑**：
	- 用于实现对设备的控制
	- 通过一组控制线与 CPU 交互，对从 CPU 收到的 I/O 命令进行译码
	- CPU 启动设备时，将启动命令发送给控制器，同时通过地址线将地址发送给控制器，由控制器的 I/O 逻辑对地址进行译码，并对所选设备进行控制
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240602152701.png)

##### 3）类型
- **按数据传送方式**：
	- 并行接口
	- 串行接口
- **按主机访问 I/O 设备的控制方式**：
	- 程序查询接口
	- 中断接口
	- DMA 接口
- **按功能选择的灵活性**：
	- 可编程接口
	- 不可编程接口

#### （3）I/O 端口
##### 1）基本概念
- **I/O 端口**：指设备控制器中可被 CPU 直接访问的寄存器，有三种类型
	- **数据寄存器**：用于缓存从设备送来的输入数据，或从 CPU 送来的传输数据
	- **状态寄存器**：保存设备的执行结果或状态信息，以供 CPU 读取
	- **控制寄存器**：由 CPU 写入，以便启动命令或更改设备模式
- I/O 端口要想能够被 CPU 访问，就要对各个端口进行编制，每个端口对应一个端口地址

##### 2）寄存器编址方式
- **独立编址**：
	- 指为每个端口分配一个 I/O 端口号
	- I/O 端口的地址空间与主存地址空间**独立**
	- 两者范围可以重叠，相同地址可能属于不同的地址空间
	- 只有 OS 使用特殊的 I/O 指令才能访问端口【普通用户程序不能访问端口】
	- **优点**：
		- I/O 端口数比主存单元少得多，只需少量地址线，使得 **I/O 端口译码简单，寻址速度更快**
		- 使用专用 I/O 指令，可使**程序更加清晰**，便于理解和检查
	- **缺点**：
		- I/O 指令少，只提供简单的传输操作，所以程序**设计的灵活性较差**
		- CPU 需要提供两组独立的存储器和设备的读/写控制信号，**增加了控制的复杂性**

- **统一编址**：
	- 又称**内存映射 I/O**
	- 指将主存地址空间分出一部分给 I/O 端口进行编址，I/O 端口和主存单元在同一地址空间的**不同分段**中
	- **根据地址范围**就能区分访问的是 I/O 端口还是主存单元
	- 用**统一的访存指令**就可访问 I/O 端口
	- **优点**：
		- 不须专门的 I/O 指令，使得 CPU 访问 I/O 的操作**更加灵活方便**
		- 使端口有较大的编址空间
	- **缺点**：
		- 端口地址占用了部分主存地址空间，使**主存的可用容量变小**
		- 识别 I/O 端口时全部地址线都需参加译码，使**译码电路更加复杂**，降低寻址速度

### 2、I/O 控制方式
- **I/O 控制**：指控制设备和主机之间的数据传送
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240602171054.png)

#### （1）程序直接控制方式
- CPU 对 I/O 设备的控制采用轮询的 I/O 方式，又称**程序轮询方式**
- **CPU 干预的频率**：
	- 很频繁，I/O 操作开始之前、完成之后需要 CPU 介入
	- 在**等待 I/O 完成的过程中 CPU 需要不断地轮询检查**
- 数据的传送单位：每次读/写**一个字**
- 数据的流向：
	- 读操作（数据输入）：I/O 设备 ---> CPU 寄存器 ---> 内存
	- 写操作（数据输出）：内存 ---> CPU 寄存器 ---> I/O 设备
- **优点**：实现简单
- **缺点**：
	- **CPU 和 I/O 设备只能串行工作**
	- CPU 需要一直轮询检查，**长期处于“忙等”状态**，CPU 利用率低
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240602163906.png)

![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240602163731.png)

#### （2）中断驱动方式
- **基本思想**：允许 I/O 设备主动打断 CPU 的运行并请求服务，从而“解放”CPU，使得其向 I/O 控制器发送读命令后可以继续做其他有用的工作
- **CPU 干预的频率**：
	- 每次 I/O 操作开始之前、完成之后需要 CPU 介入
	- 等待 I/O 完成的过程中 CPU 可以切换到别的进程执行
- 数据的传送单位：每次读/写**一个字**
- 数据的流向：
	- 读操作（数据输入）：I/O 设备 ---> CPU 寄存器 ---> 内存
	- 写操作（数据输出）：内存 ---> CPU 寄存器 ---> I/O 设备
- **优点**：
	- I/O 控制器会通过中断信号主动报告 I/O 已完成，CPU 不再需要不停地轮询
	- **CPU 和 I/O 设备可并行工作**，CPU 利用率明显提升
- **缺点**：
	- 每个字在 I/O 设备与内存之间的传输，都需要经过 CPU
	- 频繁的中断处理会消耗较多的 CPU 时间
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240602164525.png)

#### （3）DMA 方式
- **基本思想**：是在 I/O 设备和内存之间开辟直接的数据交换通路，彻底"解放” CPU
- **CPU 干预的频率**：
	- 仅在传送一个或多个数据块的**开始和结束时**，才需 CPU 干预
	- 整块数据的传送是在 DMA 控制器的控制下完成的
- 数据的传送单位：每次读/写**一个或多个块**【连续的】
- 数据的流向：
	- 读操作（数据输入）：I/O 设备 ---> 内存
	- 写操作（数据输出）：内存  ---> I/O 设备
- **优点**：
	- 数据传输以“块”为单位，CPU 介入频率进一步降低
	- 数据的传输不再需要先经过 CPU 再写入内存，数据传输效率进一步增加
	- CPU 和 I/O 设备的并行性得到提升
- **缺点**：
	- CPU 每发出一条 I/O 指令，只能读/写一个或多个连续的数据块
	- 如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU 要分别发出多条I/O 指令，进行多次中断处理才能完成
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240602165701.png)

#### （4）通道控制方式
- I/O 通道是一种特殊的处理机，可执行一系列通道指令
- 与 CPU 相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与 CPU 共享内存
- **CPU 干预的频率**：
	- 极低
	- 通道会根据 CPU 的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求 CPU 干预
- 数据的传送单位：每次读/写**一组数据块**
- 数据的流向【**在通道的控制下进行**】：
	- 读操作（数据输入）：I/O 设备 ---> 内存
	- 写操作（数据输出）：内存  ---> I/O 设备
- **优点**：
	- **CPU、通道、I/O 设备可并行工作**，资源利用率很高
	- 一个通道可以控制**多台设备与内存**的数据交换
- **缺点**：实现复杂，需要专门的通道硬件支持
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240602170531.png)


### 3、I/O 软件层次结构
- 将系统中的设备管理模块分为若干个层次，**每层都利用其下层提供的服务**，完成输入/输功能中的某些子功能，并**屏蔽这些功能的实现细节**，向高层提供服务
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604145317.png)

#### （1）用户层软件
- 用户层软件**实现了与用户交互的接口**
- 用户可直接使用该层提供的、与 I/O 操作相关的**库函数**对设备进行操作
- 用户层软件将用户请求翻译成格式化的 I/O 请求，并通过**系统调用**请求操作系统内核【下三层】的服务

#### （2）设备独立性软件
- **设备独立性**：又称**设备无关性**，使得应用程序独立于具体使用的物理设备
- 为实现设备独立性，引入了**逻辑设备**和**物理设备**两个概念
- 使用逻辑设备名的**好处**：
	- 增加设备分配的灵活性
	- 易于实现 I/O 重定向，用于 I/O 操作的设备可以更换 ，而不必改变应用程序
- 为实现设备独立性，必须在驱动程序之上设置一层**设备独立性软件**，主要功能：
	- 向上层提供统一的调用接口（如 read/write 系统调用）
	- 设备的保护
	- 差错处理
	- 设备的分配与回收
	- 数据缓冲区管理
	- 建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序

#### （3）设备驱动程序
- **与硬件直接相关**，负责**具体实现系统对设备发出的操作命令**，驱动 I/O 设备工作的驱动程序
- 每类设备设置一个设备驱动程序，它是 I/O 进程与设备控制器之间的通信程序，通常**以进程的形式存在**
- 设备具体的差别被设备驱动程序所封装，设备驱动程序向上层用户程序提供一组标准接口，用于接收上层软件发来的抽象 I/O 要求（如 read /write 命令），转换为具体要求后，**发送给设备控制器，控制 I/O 设备工作**
- 它也将由设备控制器发来的信号传送给上层软件，从而为 I/O 内核子系统隐藏设备控制器之间的差异

#### （4）中断处理程序
- 保存被中断进程的 CPU 环境，转入相应的中断处理程序进行处理，处理完毕再恢复被中断进程的现场后，返回到被中断进程
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604152911.png)

### 4、应用程序 I/O 接口
#### （1）I/O 接口的分类
- **字符设备接口**：
	- 字符设备：指数据的存取和传输是**以字符为单位**的设备（如键盘、打印机等）
	- 基本特征：
		- 传输速率较低、不可寻址
		- I/O 通常采用中断驱动方式
- **块设备接口**：
	- 块设备：指数据的存取和传输是**以数据块为单位**的设备（如磁盘）
	- 基本特征：
		- 传输速率高、可寻址
		- I/O 通常采用 DMA 方式
- **网络设备接口**：
	- 又称网络套接字（socket）接口
	- 套接字接口的系统调用使应用程序创建的本地套接字连接到远程应用程序创建的创建的套接字，通过此连接发送和接收数据

#### （2）阻塞 I/O 和非阻塞 I/O
- **阻塞 I/O** ：
	- 指当用户进程调用 I/O 操作时，进程就被阻塞，需要等待 I/O 操作完成，进程才被唤醒继续执行
	- 大多数 OS 提供的 I/O 接口都是采用阻塞 I/O
	- **优点**：操作简单，实现难度低，适合并发量小的应用开发
	- **缺点**：I/O 执行阶段进程会一直阻塞下去
- **非阻塞 I/O** ：
	- 指用户进程调用 I/O 操作时，不阻塞该进程，但进程需要通过轮询的方式来查询 I/O 操作是否完成
	- **优点**：进程在等待 I/O 期间不会被阻塞，可以做其他事情，适合并发量大的应用开发
	- **缺点**：轮询方式询问 I/O 结果，会占用 CPU 的时间


## 二、设备独立性软件
### 1、设备独立性软件
- 与设备无关的软件是 I/O 系统的最高层软件，它的下层是设备驱动程序，其间的界限因操作系统和设备的不同而有所差异

### 2、高速缓存与缓冲区
#### （1）磁盘高速缓存
- 操作系统中使用磁盘高速缓存技术来提高磁盘的 I/O 速度，对访问高速缓存要比访问原始磁盘数据更为高效 
- 磁盘高速缓存**逻辑上属于磁盘**，**物理上是驻留在内存中的盘块**
- 磁盘高速缓存在内存中分为两种形式：
	1. 在内存中开辟一个独立的空间作为磁盘高速缓存。大小固定
	2. 把未利用内存空间作为一个缓冲池，仅供请求分页系统和磁盘 I/O 时共享

#### （2）缓冲区
- **引入缓冲区的目的**：
	- 缓和 CPU 与 I/O 设备间速度不匹配的矛盾
	- 减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制
	- 解决基本数据单元大小（即数据粒度）不匹配的问题
	- 提高 CPU 和 I/O 设备之间的并行性
- **实现方法**：
	- 采用硬件缓冲器，但由于成本太高，除一些关键部位外，一般不采用硬件缓冲器
	- 采用缓冲区（位于内存区域）
- 根据系统设置**缓冲区的个数**，缓冲技术可以分为：
##### 1）单缓冲
- T时间：数据从磁盘 ---> 缓冲区
- M时间：数据从缓冲区 ---> 用户
- C 时间：CPU 对一块数据处理的时间
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604162046.png)
- **注意**：
	- 当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出
	- 当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604162941.png)
- **结论**：采用单缓冲策略，处理一块数据平均耗时 **Max (C, T)+M**

##### 2）双缓冲
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604163543.png)
- 假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604163708.png)
- **结论**：采用双缓冲策略，处理一个数据块的平均耗时为 **Max (T, C+M)**

##### 3）循环缓冲
- 将多个**大小相等**的缓冲区连接成一个**循环队列**
- 下图中橙色表示已充满数据的缓冲区，绿色表示空缓冲区
- 当需要向缓冲区中冲入数据时，只要找到in指针指向的空缓冲区，向其中冲入数据，然后再把in指针指向下一个空缓冲区
- 当需要取出满缓冲区的内容时，找到 out 指针执行的满缓冲，读完数据后，将指针指向下一个满缓冲区。
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604164039.png)

##### 4）缓冲池
- 缓冲池由系统中共用的缓冲区组成
- 缓冲区**按使用状况**可以分为：
	- **空缓冲队列**
	- **输入队列**：存储的是从设备发送给内存的数据
	- **输出队列**：存储的是从内存发送给设备的数据
- 根据一个缓冲区**在实际运算中扮演的功能**不同分为四种工作缓冲区：
	- 用于**收容输入数据**的工作缓冲区（hin）
	- 用于**提取输入数据**的工作缓冲区（sin）
	- 用于**收容输出数据**的工作缓冲区（hout）
	- 用于**提取输出数据**的工作缓冲区（sout）
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604164403.png)
- **收容输入**：
	- 输入进程需要输入数据时，从空缓冲队列的队首摘下一个空缓冲区，作为收容输入工作缓冲区，然后将数据输入其中，装满后再将它挂到输入队列的队尾
- **提取输入**：
	- 计算进程需要输入数据时，从输入队列的队首取得一个缓冲区，作为提取输入工作缓冲区，从中提取数据，用完该数据后将它挂到空缓冲队列的队尾
- **收容输出**：
	- 计算进程需要输出数据时，从空缓冲队列的队首取得一个空缓冲区，作为收容输出工作缓冲区，当其中装满数据后，再将它挂到输出队列的队尾
- **提取输出**：
	- 输出进程需要输出数据时，从输出队列的队首取得一个装满输出数据的缓冲区，作为提取输出工作缓冲区，当数据提取完后，再将它挂到空缓冲队列的队尾

#### （3）高速缓存与缓冲区的对比
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240604165750.png)

### 3、设备分配与回收
- **设备分配**：指根据用户的 I/O 请求分配所需的设备
#### （1）设备分配的策略
##### 1）设备分配原则
- **设备固有属性**决定了设备的使用方式（充分发挥设备的使用效率，尽可能让设备忙碌）
- **设备独立性**可以提高设备分配的灵活性和设备的利用率（设备独立性是指用户使用设备的透明性，即用户程序与实际使用的物理设备无关）
- **设备安全性**可以保证分配设备时不会导致永久阻塞（要避免造成进程死锁）

##### 2）设备的固有属性
- **独占设备**：将它分配给某个进程后，便由该进程独占，直至进程完成或释放该设备
- **共享设备**：可将它同时分配给多个进程，需要合理调度各个进程访问该设备的先后次序
- **虚拟设备**：属于可共享设备，可将它同时分配给多个进程使用

##### 3）设备分配算法
- **FCFS 算法**：根据设备提出请求的先后次序
- **最高优先级算法**：根据设备的优先级

##### 4）设备分配的方式
- **静态分配**：
	- 主要用于对**独占设备**的分配
	- 进程运行前为其分配全部所需资源，运行结束后归还资源
	- 一旦分配，这些设备、控制器就一直为该作业所占用，直到该作业被撤销
	- **特点**：不会出现死锁，但设备的使用效率低
- **动态分配**：
	- 进程运行过程中通过系统调用命令动态申请设备资源
	- 一旦用完，便立即释放
	- **特点**：有利于提高设备利用率，但若分配算法使用不当，则有可能造成进程死锁

##### 5）设备分配中的安全性
- 设备分配安全性是指设备分配中应防止发生进程死锁
- **安全分配方式**：
	- 每当进程发出 I/O 请求后，便进入阻塞态，本次 I/O 完成后才将进程唤醒
	- 在一个时间段内每个进程只能使用一个设备
	- **优点**：破坏了请求等待条件，不会死锁，设备分配安全
	- **缺点**：对于一个进程来说，CPU 和 I/O 设备只能串行工作，系统资源利用率低

- **不安全分配方式**：
	- 进程发出 I/O 请求后，系统为其分配 I/O 设备，进程可继续执行，之后还可以发出新的 I/O 请求，只有某个 I/O 请求得不到满足时才将进程阻塞
	- 一个进程可以同时使用多个设备
	- **优点**：进程的计算任务和 I/O 任务可以并行处理，使进程推进
	- **缺点**：有可能发生死锁

#### （2）设备分配的数据结构
- “设备、控制器、通道”之间的关系：一个通道可控制多个设备控制器，每个设备控制器可控制多个设备
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240605151539.png)

##### 1）设备控制表（DCT）
- 系统为每个设备配置一张 DCT，用于记录设备情况
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240605151817.png)

##### 2）控制器控制表（COCT）
- 每个设备控制器对应一张 COCT
- OS 根据 COCT 的信息对控制器进行操作和管理
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240605151934.png)

##### 3）通道控制表（CHCT）
- 每个通道对应一张 CHCT
- OS 根据 CHCT 的信息对通道进行操作和管理
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240605152039.png)

##### 4）系统设备表（SDT）
- 记录了**系统中全部设备**的情况
- 每个设备对应一个表目
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240605152145.png)

#### （3）设备分配的步骤
- 以独占设备为例：
1. **分配设备**：
	- 首先根据 I/O 请求中的**物理设备名**，查找 SDT，从中找出该设备的 DCT
	- 再根据 DCT 中的设备状态字段，可知该设备的状态：
		- 若忙，则将该进程 PCB 挂到设备等待队列
		- 若不忙，则根据一定的策略将该设备分配给该进程
2. **分配控制器**：
	- 根据 DCT 找到 COCT，查询控制器的状态：
		- 若忙，则将该进程 PCB 挂到控制器等待队列
		- 若不忙，则将控制器分配给该进程
3. **分配通道**：
	- 根据 COCT 找到 CHCT，查询通道的状态：
		- 若忙，则将进程 PCB 挂到通道等待队列
		- 若不忙，则将通道分配给该进程
- **注意**：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动 I/O设备进行数据传送
#### （4）逻辑设备名到物理设备名的映射
- **目的**：为了实现设备的独立性，进程中使用逻辑设备名来请求某类设备
- **逻辑设备表（LUT）**：
	- 用于将逻辑设备名映射为物理设备名
	- 每个表项包含 3 项内容：
		- 逻辑设备名
		- 物理设备名
		- 设备驱动程序的入口地址
	- 两种方式：
		1. **整个系统只设置一张 LUT**：
			- 所有进程的设备分配情况都记录在同一张 LUT 中
			- 要求所有用户不能使用相同的逻辑设备名
			- 主要适用于单用户系统
		2. **为每个用户设置一张 LUT**：
			- 同时在多用户系统中都配置系统设备表
			- 不同用户可以使用相同的逻辑设备名
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240606152840.png)


### 4 、SPOOLing 技术（假脱机技术）
#### （1）脱机技术
- 批处理阶段引入了**脱机输入/输出**技术（用磁带完成）
- **引入目的**：
	- 缓解了 CPU 与慢速 I/O 设备的速度矛盾
	- 实现预输入、缓输出
- **组成**：外围控制机 + 更高速的设备（磁带）
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240606154710.png)


#### （2）假脱机技术的实现
- **假脱机技术**：又叫 SPOOLing 技术，用**软件**的方式模拟脱机技术，不需要外围机，是一项将**独占设备改造成共享设备**的软件技术
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240606154731.png)
##### 1）输入井和输出井
- 在磁盘上开辟出的两个存储区域
- **输入井**：模拟脱机输入时的磁盘，用于收容 I/O 设备输入的数据
- **输出井**：模拟脱机输出时的磁盘，用于收容用户程序的输出数据
- 一个进程的输入（或输出）数据保存为一个文件
- 所有进程的数据输入（或输出）文件链接成一个输入（或输出）队列

##### 2）输入缓冲区和输出缓冲区
- 在内存中开辟的两个缓冲区
- **输入缓冲区**：暂存由输入设备送来的数据，以后早传送到输入井
- **输出缓冲区**：暂存从输出井送来的数据，以后再传送到输出设备

##### 3）输入进程和输出进程
- 用于模拟脱机技术的外围控制机
- **输入进程**：
	- 将用户要求的数据从输入设备传送到输入缓冲区，再存放到输入井中
	- CPU 需要输入数据时，直接从输入井中读入内存
- **输出进程**：
	- 将用户要求输入的数据从内存传送到输出井
	- 待输出设备空闲时，再将输出井中的数据经输出缓冲区输出至输出设备。

##### 4）井管理程序
- 用于控制作业与磁盘井之间信息的交换

##### 5）SPOOLing 系统的特点
- **提高了IO速度**，将对低速IO设备执行的IO操作演变为对磁盘缓冲区中数据的存取
- **将独占设备变为共享设备**，且实际上没有为任何进程分配设备
- **提高了独占设备的利用率**，缓和了CPU和低速IO设备之间的速度不匹配的矛盾
- **实现了虚拟设备功能**，对每个进程而言，都认为自己独占了一个设备
- **以空间换时间**，需要磁盘空间（输入输出井）和内存空间（输入输出缓冲区）

#### （3）共享打印机的实现
- **打印机是独占设备**，只允许各个进程串行使用设备，一段时间内只能满足一个进程的请求
- 利用用 SPOOLing 技术将其**改造成“共享设备”**，实现原理：
	- 当用户进程请求打印输出时，SPOOLing 系统同意打印，但是并不真正立即把打印机分配给该进程，而由假脱机管理进程完成两项任务：
		1. 在**磁盘缓冲区**中为之申请一个空闲盘块，并将要打印的数据送入其中暂存
		2. 为用户进程申请一张空白的**用户请求打印表**，并将用户的打印要求填入其中，再将该表挂到假脱机文件队列上
	- **当打印机空闲时**，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求打印数据从输出井传送到输出缓冲区，再输出到打印机打印
- 虽然系统中只有一台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于一个逻辑设备）使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240606161932.png)


### 5、设备驱动程序接口
- 设备驱动程序：是 I/O 系统的上层与设备控制器之间的通信程序
- **具有的功能**：
	- 接收由上层软件发来的命令和参数，并将抽象要求转换为与设备相关的具体要求【例如，将抽象要求中的盘块号转换为磁盘的盘面号、磁道号及扇区号】
	- 检查用户 IO 请求的合法性，了解设备的工作状态，传递与设备操作有关的参数，设置设备的工作方式
	- 发出 I/O 命令，若设备空闲，则立即启动它，完成指定的 I/O 操作；若设备忙，则将请求者的 PCB 挂到设备队列上等待
	- 及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理
- 与普通应用/系统程序的**差异**：
	- 设备驱动程序将抽象的I/O 请求转换成具体的 I/O 操作后，传送给设备控制器，并将设备控制器中记录的设备状态和 I/O操作的完成情况及时地反馈给请求进程
	- 设备驱动程序与设备采用的 I/O 控制方式紧密相关，常用的 I/O 控制方式是**中断驱动方式和 DMA 方式**
	- 设备驱动程序与硬件密切相关，对于不同类型的设备，应配置不同的设备驱动程序
	- 由于设备驱动程序与硬件紧密相关，目前很多设**备驱动程序的基本部分已固化在 ROM** 
	- 设备驱动程序应**允许同时多次调用执行**
- 如何使所有的设备驱动程序都有统一的接口：
	- 要求每个设备驱动程序与操作系统之间都有相同或相近的接口，便于添加新的设备驱动程序和编制设备驱动程序
	- 要将抽象的设备名转换为具体的物理设备名，并且进一步找到相应的设备驱动程序入口
	- 对设备进行保护
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608154956.png)
- 对于每种设备类型，例如磁盘，OS 都要定义一组驱动程序必须支持的函数（读、写、格式化等）
- 驱动程序包含一张表格，具有针对这些函数指向驱动程序自身的指针
- 装载驱动程序时，OS 记录这个函数指针表的地址，当 OS 调用一个函数时，可通过这张表格发出间接调用
- 函数指针表定义了驱动程序与操作系统其余部分之间的接口

## 三、磁盘与固态硬盘
### 1、磁盘
#### （1）磁盘、磁道、扇区
- 磁盘的表面是由一些磁性物质组成，可以用这些磁性物理记录二进制数据
- 磁盘表面被划分成多个磁道
- 每个磁道被划分为多个扇区，每个扇区就是一个“磁盘块”
- 每个扇区的数据量相同（如 1 KB）
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608162835.png)

#### （2）盘面、盘柱
- 磁盘是由多个盘片摞起来的，每个盘片有两个盘面
- 每个盘面都对应一个磁头，所有的磁头都连在同一个磁臂上
- 磁臂可以沿着盘面作径向运动，从而带动磁头到达不同的磁道来对不同扇区的读写操作
- 所有盘面中的相对位置相同的磁道组成了柱面
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608165227.png)

#### （3）在磁盘中读/写数据
- 在磁盘中读写数据，需要借助磁头
	- step 1：**将磁头移动**到想要读/写的**扇区所在的磁道**
	- step 2：**磁盘会转动**，让**目标扇区从磁头下面划过**，才能完成对扇区的读/写操作

#### （4）磁盘的物理地址
- 使用 **（柱面号，盘面号，扇区号）** 来定位任意一个磁盘块
- 文件数据存放在外存中的几号块，这里的块号就可以转换为（柱面号，盘面号，扇区号）的地址形式
- 根据物理地址读取一个“块”：
	1. 根据柱面号移动磁臂，让**磁头指向指定柱面**
	2. 激活**指定盘面对应的磁头**
	3. 磁盘旋转的过程，**指定的扇区**会从磁头下面划过，这样就完成了对指定扇区的读写

#### （5）磁盘的分类
- 根据**磁头是否可以活动**划分：
	- 活动头磁盘
	- 固定头磁盘
- 根据**盘面是否可以更换**划分：
	- 可换磁盘
	- 固定盘磁盘

### 2、磁盘的管理
#### （1）磁盘初始化
- **低级格式化**【物理格式化】：
	- 在磁盘可以存储数据之前，**将它分为扇区**，以便磁盘控制器能够进行读写操作
	- 每个扇区通常由头部、数据区域（通常为 512 B 大小）和尾部组成
	- 头部和尾部包含了一些磁盘控制器的使用信息：
		- 利用磁道号、磁头号和扇区号标志一个扇区
		- 利用 CRC 字段对扇区进行校验

#### （2）分区
- 将磁盘**分为由一个或多个柱面组成的分区** (如 C 区，D 区)，每个分区的起始扇区和大小都记在磁盘主引导记录的分区表
- **对物理分区进行逻辑格式化**【创建文件系统】，操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲空间和己分配的空间以及一个初始为空的目录
- **簇**：
	- 将多个相邻的扇区组合在一起，提高效率
	- 一簇只能存放一个文件的内容
	- 文件所占用的空间只能是**簇的整数倍**
	- 文件大小小于一簇（甚至是 0 字节），也要占用一簇的空间

#### （3）引导块
- 计算机启动时需要运行**初始化程序（自举程序）** 来初始化 CPU、寄存器、设备控制器和内存等，接着启动 OS
- **ROM 中存放很小的自举装入程序**：避免改变自举代码而需改变 ROM 硬件
- 完整的自举程序存放在磁盘的启动块（引导块/启动分区）上，启动块位于磁盘的固定位置
- 拥有启动分区的磁盘称为**启动磁盘**或**系统磁盘**（C: 盘）
- 计算机开机工作：先运行“自举装入程序”，通过执行该程序就可找到引导块，并将完整的“自举程序”读入内存，完成初始化

#### （4）坏块的管理
- 简单的磁盘：逻辑格式化时将坏块标记出来
- 复杂的磁盘：磁盘控制器维护一个坏块链，并管理备用扇区

### 3、磁盘调度算法
- **磁盘调度算法的目的**：为了提高磁盘的访问性能，一般是通过优化磁盘的访问请求顺序来做到的
- **寻道的时间是磁盘访问最耗时的部分**，如果请求顺序优化的得当，可以节省一些不必要的寻道时间，从而提高磁盘的访问性能
- 绝大数 OS 为改善磁盘访问时间，以簇（一组块）为单位进行空间划分
#### （1）一次磁盘读/写操作需要的时间
##### 1）寻道时间 Ts
- 在读/写数据前，需要将磁头移动到指定磁道所花费的时间
- 分两步：
	1. **启动磁头臂**消耗的时间 s
	2. **移动磁头**消耗的时间：假设磁头匀速移动，每跨越一个磁道消耗时间为 m，共跨越 n 条磁道
- **Ts=s+m×n**

##### 2）延迟时间 Tr
- 通过旋转磁盘，使磁头定位到目标扇区所需要的时间
- 设磁盘转速 r（单位：转/秒）
- **Tr= $\frac{1}{2}*\frac{1}{r}=\frac{1}{2r}$**
- 1/r 就是转一圈所需的时间，找到目标扇区平均需要转半圈，因此再乘以 1/2

##### 3）传输时间 Tt
- 从磁盘读出或向磁盘写入数据所经历的时间
- 设磁盘转速 r，此次读/写的字节数为 b，每个磁道上的字节数为 N
- **Tt=**$\frac{1}{r}*\frac{b}{N}=\frac{b}{rN}$
- 每个磁道可存 N 字节数据，因此 b 字节数据需要 b/N 个磁道【扇区】才能存储
- **平均传输时间等于一个扇区划过磁头下方所需要的时间**【2022 大题】
- 读/写一个磁道所需的时间刚好是转一圈的时间 1/r

##### 4）总的平均时间
- T= $T_s+\frac{1}{2r}+\frac{b}{rN}$
- 无法通过操作系统优化延迟时间和传输时间，所以只能优化寻道时间

#### （2）调度算法
- 假设有一个请求序列，每个数字代表磁道的位置：98，183，37，122，14，124，65，67，初始磁头当前的位置是在第 53 磁道
##### 1）先来先服务算法 FCFS
- **思想**：先到来的请求，先被服务
- **优点**：
	- 公平，简单
	- 请求访问的磁道比较集中的话算法性能还算可以
- **缺点**：
	- 比较简单粗暴
	- 如果大量进程竞争使用磁盘，请求访问的磁道可能会很分散
	- 算法在性能上就会显得很差，因为寻道时间过长
- **处理顺序**：98，183，37，122，14，124，65，67
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608200246.png)

##### 2）最短寻找时间算法 SSTF
- **思想**：优先选择从当前磁头位置所需寻道时间最短的请求
- **优点**：
	- 是贪心算法的思想，只是选择眼前最优，但是总体未必最优
	- 比 FCFS 效果好
- **缺点**：
	- 存在饥饿现象
	- 产生饥饿的原因是**磁头在一小块区域来回移动**
- **处理顺序**：65，67，37，14，98，122，124，183
![](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608200246.png)

##### 3）扫描/电梯算法 SCAN
- **思想**：磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向
- **优点**：
	- 性能较好，寻道时间较短
	- 不会产生饥饿现象
- **缺点**：
	- 中间部分的磁道会比较占便宜
	- 中间部分相比其他部分响应的频率会比较多
	- 也就是说每个磁道的响应频率存在差异
- **处理顺序**：
	- 假设扫描调度算先朝磁道号减少的方向移动
	- 磁头先响应左边的请求
	- 直到到达最左端后，才开始反向移动，响应右边的请求
	- 7，14，0，65，67，98，122，124，183
- **改进 LOOK 算法**：只要在磁头移动方向上不再有请求，就立即改变磁头方向
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608200254.png)

##### 4）循环扫描算法 C-SCAN
- **思想**：
	- 只有磁头朝某个特定方向移动时，才处理磁道访问请求
	- 而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头
	- 这个过程是很快的，并且返回中途不处理任何请求
	- **特点：磁道只响应一个方向上的请求**
- **优点**：对于各个位置磁道响应频率很平均
- **缺点**：相比于 SCAN 算法，平均寻道时间更长
- **处理顺序**：
	- 假设循环扫描调度算先朝磁道增加的方向移动
	- 磁头先响应了右边的请求
	- 直到碰到了最右端的磁道 199，就立即回到磁盘的开始处
	- 但这个返回的途中是不响应任何请求的
	- 直到到达最开始的磁道后，才继续顺序响应右边的请求
	- 65，67，98，122，124，183，199，0，14，37
- **改进 C-LOOK 算法**：只要在磁头移动方向上不再有请求，就立即改变磁头方向
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608200301.png)

#### （3）减少磁盘延迟时间的方法
- 磁头读入一个扇区数据后需要一小段时间处理
- 如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”
##### 1）交替编号
- **思想**：让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608201651.png)
- **思考**：磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）
- 读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以**减少磁头移动消耗的时间**
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608201940.png)

##### 2）错位命名
- **思想**：让相邻盘面的扇区编号错位
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240608202223.png)

#### （4）固态硬盘